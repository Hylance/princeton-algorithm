// quick find//data structureinteger array id[] of length Ninterpretation: p and q are connected iff they have the same id//Find check if p and q have the same id.//UnionTo merge components containing p and q, change all entries whose id equals id[p] to id[q].//java implementaitonpublic class QuickFIndUF{	private int[] id;	public QiuickFIndUN(int N){		id =new int[N];		for (int i= 0; i<N£»i++)			id[i]=i;	}	public boolean connected(int p, intq){		return id[p]==id[q];	}	public void union(int p, int q){		int pid =id[p];		int qid =id[q];		for (int i =0; i<id.length; i++)			if (id[i]==pid)			id[i]=qid;	}//quick union //data structure Integer array id[] of length N.Interpretation: id[i] is parent of i.Root of i is id[id[...id[i]...]]].//FindCheck if p and q have the same root.//UnionTo merge components containing p and q set the id of pÕs root to the id of qÕs root.//java implementationpublic class QuickUnionUF{	private int[] id;	public QiuckUnionUF(int N){		id=new int[N];		for (int i=0; i<N; i++)			id[i]=i;	}	private int root(int i){		while (i !=id [i]){			i=id[i];		}		reutrn i;	}	public boolean connected (int p, int q){		return root(p)==root (q);	}	public void union (int p, int q){		int i =root(p);		int j =root(q);		id[i] =j;	}}// weighted quick-union//data structureInteger array id[] of length N.Interpretation: id[i] is parent of i.Root of i is id[id[...id[i]...]]].array sz[i]:count number of objects in the tree rooted at i.//findCheck if p and q have the same root.//unionlink root of smaller tree to root of larger treeupdate the sz[] array//java implementationpublic class WeightedQuickUnionUF{	private int[] id;	private int[] sz;	public WeightedQiuckUnionUF(int N){		id=new int[N];		for (int i=0; i<N; i++)			id[i]=i;	}	private int root(int i){		while (i !=id [i]){			i=id[i];		}		reutrn i;	}	public boolean connected (int p, int q){		return root(p)==root (q);	}	public void union (int p, int q){		int i =root(p);		int j =root(q);		if(i==j)			return;		if (sz[i]<sz[j]){			id[i]=j;			sz[j]+=sz[i];		}		else{			id[j]=i:			sz[i]+=sz[j];		}		id[i] =j;	}}//weighted quick union with path compressionJust after computing the root of p, set the id of each examined node to  point  to that root.//java implementationpublic class WeightedQuickUnionUF{	private int[] id;	private int[] sz;	public WeightedQiuckUnionUF(int N){		id=new int[N];		for (int i=0; i<N; i++)			id[i]=i;	}	private int root(int i){		while (i !=id [i]){			id[i]=id[id[i]]; //only added one more line!			i=id[i];		}		reutrn i;	}	public boolean connected (int p, int q){		return root(p)==root (q);	}	public void union (int p, int q){		int i =root(p);		int j =root(q);		if(i==j)			return;		if (sz[i]<sz[j]){			id[i]=j;			sz[j]+=sz[i];		}		else{			id[j]=i:			sz[i]+=sz[j];		}		id[i] =j;	}}algorithm					worst-cast timequick-find					MNquick-union				MNweighted QU				N+MlogNQU+path compression			N+MlogNweighted QU+path compression	N+Mlg*N